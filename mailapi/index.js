const express = require('express');
const http = require('http');
const { Server } = require('socket.io');
const mongoose = require('mongoose');
const cors = require('cors');
const bodyParser = require('body-parser');
const crypto = require('crypto');
const fs = require('fs');
const path = require('path');
const util = require('util');
const writeFile = util.promisify(fs.writeFile);
const appendFile = util.promisify(fs.appendFile);

const app = express();
const server = http.createServer(app);
const io = new Server(server, {
  cors: { origin: "*" }
});

// Device analytics endpoint
app.get('/api/device-emails/analytics', authKey, async (req, res) => {
  try {
    // Aggregate device statistics
    const deviceStats = await DeviceEmail.aggregate([
      {
        $group: {
          _id: '$deviceId',
          generatedCount: {
            $sum: {
              $cond: [{ $eq: ['$type', 'generated'] }, 1, 0]
            }
          },
          receivedCount: {
            $sum: {
              $cond: [{ $eq: ['$type', 'received'] }, 1, 0]
            }
          },
          lastActivity: { $max: '$createdAt' },
          totalEmails: { $sum: 1 }
        }
      },
      {
        $project: {
          deviceId: '$_id',
          generatedCount: 1,
          receivedCount: 1,
          lastActivity: 1,
          totalEmails: 1,
          _id: 0
        }
      },
      {
        $sort: { totalEmails: -1 }
      }
    ]);

    res.json(deviceStats);
  } catch (err) {
    console.error('Error getting device analytics:', err);
    res.status(500).send('Error getting device analytics');
  }
});

// Activity logs endpoint
app.get('/admin/activity', authKey, async (req, res) => {
  try {
    const limit = parseInt(req.query.limit) || 50;
    const filter = req.query.filter || 'all';
    
    let activities = [];
    
    // Get recent device emails (generated and received)
    const deviceEmailsQuery = filter === 'all' ? {} : 
      filter === 'generated' ? { type: 'generated' } :
      filter === 'received' ? { type: 'received' } : {};
    
    const deviceEmails = await DeviceEmail.find(deviceEmailsQuery)
      .sort({ createdAt: -1 })
      .limit(limit)
      .lean();
    
    // Transform device emails to activity format
    activities = deviceEmails.map(email => ({
      type: email.type,
      description: email.type === 'generated' 
        ? `Email ${email.email} generated by device ${email.deviceId}`
        : `Email received for ${email.email} (device ${email.deviceId})`,
      timestamp: email.createdAt,
      deviceId: email.deviceId,
      email: email.email
    }));
    
    // Sort by timestamp
    activities.sort((a, b) => new Date(b.timestamp) - new Date(a.timestamp));
    
    res.json(activities.slice(0, limit));
  } catch (err) {
    console.error('Error getting activity logs:', err);
    res.status(500).json({ error: 'Error getting activity logs', message: err.message });
  }
});

// === CONFIG ===
const PORT = 3001;
const MONGO_URI = 'mongodb+srv://turbomail:we1we2we3@turbomail.gjohjma.mongodb.net/turbomail?retryWrites=true&w=majority&appName=turbomail';
let API_KEY = 'supersecretapikey123'; // Made mutable for updates
const ALLOWED_DOMAINS = ['oplex.online', 'worldwides.help', 'agrovia.store', 'tempbox.pro'];
const HARAKA_HOST_LIST_PATH = path.join(__dirname, '../haraka/config/host_list');
const FAILED_EMAILS_LOG = path.join(__dirname, 'failed_emails.log');

// === DB SETUP ===
mongoose.connect(MONGO_URI).then(() => {
  console.log('ðŸ“¦ Connected to MongoDB');
}).catch(console.error);

const EmailSchema = new mongoose.Schema({
  from: String,
  to: [String], // Array of Strings to support multiple recipients
  subject: String,
  body: String,
  html: String,
  date: String,
  headers: {
    messageId: String,
    contentType: String,
    mimeVersion: String
  }
});
const Email = mongoose.model('Email', EmailSchema);

// Device-based email storage schema
const DeviceEmailSchema = new mongoose.Schema({
  deviceId: { type: String, required: true, index: true },
  email: { type: String, required: true },
  type: { type: String, enum: ['generated', 'received'], required: true },
  createdAt: { type: Date, default: Date.now },
  // For received emails
  from: String,
  subject: String,
  body: String,
  html: String,
  raw: String, // Store complete raw email content
  receivedAt: Date,
  headers: {
    messageId: String,
    contentType: String,
    mimeVersion: String
  }
});
const DeviceEmail = mongoose.model('DeviceEmail', DeviceEmailSchema);

// === MIDDLEWARE ===
app.use(cors());
app.use(bodyParser.json());
app.use(express.static('public'));

// === API KEY PROTECTOR ===
function authKey(req, res, next) {
  if (req.query.key !== API_KEY) {
    return res.status(403).send('Forbidden: Invalid API Key');
  }
  next();
}

// === SOCKET.IO CONNECTION ===
io.on('connection', (socket) => {
  console.log('ðŸ‘¤ User connected via WebSocket');
});

// === BACKUP FUNCTIONS ===
async function logFailedEmail(mail, error, timestamp) {
  try {
    const logEntry = {
      timestamp,
      mail,
      error: error.message,
      status: 'failed_to_save'
    };
    
    await appendFile(FAILED_EMAILS_LOG, JSON.stringify(logEntry) + '\n');
    console.log('ðŸ“ Failed email logged to backup file');
  } catch (logErr) {
    console.error('âŒ Failed to log failed email:', logErr.message);
  }
}

// Function to retry failed emails from log
async function retryFailedEmails() {
  try {
    if (!fs.existsSync(FAILED_EMAILS_LOG)) {
      return { message: 'No failed emails log found' };
    }
    
    const logContent = fs.readFileSync(FAILED_EMAILS_LOG, 'utf8');
    const lines = logContent.trim().split('\n').filter(line => line);
    
    let retried = 0;
    let successful = 0;
    
    for (const line of lines) {
      try {
        const logEntry = JSON.parse(line);
        await Email.create(logEntry.mail);
        successful++;
      } catch (err) {
        console.error('âŒ Retry failed for email:', err.message);
      }
      retried++;
    }
    
    // Clear the log file after processing
    if (successful > 0) {
      await writeFile(FAILED_EMAILS_LOG, '');
    }
    
    return { retried, successful, failed: retried - successful };
  } catch (err) {
    console.error('âŒ Error retrying failed emails:', err.message);
    return { error: err.message };
  }
}

// === ðŸ“¥ RECEIVE MAIL FROM HARAKA ===
app.post('/api/receive-mail', authKey, async (req, res) => {
  const mail = req.body;
  
  try {
    // Log raw email data for debugging
    console.log('ðŸ“§ Raw email received:', {
      from: mail.from,
      to: mail.to,
      messageId: mail.messageId,
      timestamp: mail.timestamp,
      rawSize: mail.raw ? mail.raw.length : 0,
      hasRawData: !!mail.raw
    });
    
    // Additional validation
    if (!mail.raw || mail.raw.length === 0) {
      console.warn('âš ï¸ Warning: No raw email data received or empty raw data');
    } else {
      console.log(`âœ… Raw email data successfully received: ${mail.raw.length} bytes`);
    }
    
    // Parse basic email information from raw content
    let subject = '(no subject)';
    let body = '';
    
    if (mail.raw) {
      const lines = mail.raw.split('\n');
      let inHeaders = true;
      
      for (const line of lines) {
        if (inHeaders) {
          if (line.trim() === '') {
            inHeaders = false;
            continue;
          }
          if (line.startsWith('Subject: ')) {
            subject = line.substring(9).trim();
          }
        } else {
          body += line + '\n';
        }
      }
      body = body.trim();
    }
    
    // Store received email in database for each recipient
    const recipients = Array.isArray(mail.to) ? mail.to : [mail.to];
    
    for (const recipient of recipients) {
      if (recipient) {
        // Find devices that have this email
        const devices = await Device.find({ email: recipient });
        
        for (const device of devices) {
          const newEmail = new DeviceEmail({
            deviceId: device.deviceId,
            email: recipient,
            type: 'received',
            from: mail.from || '',
            to: recipient,
            subject: subject,
            body: body,
            raw: mail.raw, // Store complete raw email content
            messageId: mail.messageId,
            timestamp: mail.timestamp || new Date().toISOString(),
            received: new Date().toISOString()
          });
          
          await newEmail.save();
          console.log(`ðŸ’¾ Email stored in database for device: ${device.deviceId}`);
        }
      }
    }
    
    // ðŸš€ Send complete raw email data to frontend via real-time socket
    io.emit('new_mail', {
      from: mail.from,
      to: mail.to,
      subject: subject,
      body: body,
      raw: mail.raw, // 100% raw email content as received
      timestamp: mail.timestamp || new Date().toISOString(),
      messageId: mail.messageId,
      received: new Date().toISOString()
    });
    
    console.log('ðŸ“¡ Raw email data stored in MongoDB and sent to frontend via socket');
    
    res.json({ 
      success: true, 
      message: 'Raw email data stored in database and sent via socket',
      messageId: mail.messageId,
      recipients: recipients.length
    });
    
  } catch (err) {
    console.error('âŒ Error processing raw email:', err);
    res.status(500).json({ 
      success: false, 
      error: 'Error processing raw email',
      message: err.message 
    });
  }
});

// === ðŸ“© RANDOM EMAIL GENERATOR ===
app.get('/generate', authKey, async (req, res) => {
  const { deviceId } = req.query;
  let email;
  let attempts = 0;
  const maxAttempts = 10;
  
  // Keep generating until we find a unique email for this device
  do {
    const randomUser = crypto.randomBytes(4).toString('hex');
    const domain = ALLOWED_DOMAINS[Math.floor(Math.random() * ALLOWED_DOMAINS.length)];
    email = `${randomUser}@${domain}`;
    attempts++;
    
    // Check if email already exists for this device
    if (deviceId) {
      const existingEmail = await DeviceEmail.findOne({
        deviceId,
        email,
        type: 'generated'
      });
      
      if (!existingEmail) {
        // Email is unique, store it and break
        try {
          await DeviceEmail.create({
            deviceId,
            email,
            type: 'generated'
          });
          break;
        } catch (err) {
          console.error('Error storing generated email:', err);
        }
      }
    } else {
      // No device ID provided, just return the email
      break;
    }
  } while (attempts < maxAttempts);
  
  res.send({ email });
});

// === âœï¸ MANUAL EMAIL GENERATOR ===
app.get('/generate/manual', authKey, async (req, res) => {
  const { username, domain, deviceId } = req.query;
  if (!username || !domain) return res.status(400).send('username and domain required');
  if (!ALLOWED_DOMAINS.includes(domain)) return res.status(400).send('domain not allowed');
  
  const email = `${username}@${domain}`;
  
  // Check if email already exists for this device
  if (deviceId) {
    try {
      const existingEmail = await DeviceEmail.findOne({
        deviceId,
        email,
        type: 'generated'
      });
      
      if (existingEmail) {
        return res.status(409).json({
          error: 'Email already exists',
          message: 'This email name already exists for your device. Please use a different name.',
          email: email
        });
      }
      
      // Email is unique, store it
      await DeviceEmail.create({
        deviceId,
        email,
        type: 'generated'
      });
    } catch (err) {
      console.error('Error storing generated email:', err);
      return res.status(500).send('Error creating email');
    }
  }
  
  res.send({ email });
});

// === ðŸ“¬ GET INBOX FOR EMAIL ===
app.get('/inbox/:email', authKey, async (req, res) => {
  const email = req.params.email;
  const messages = await Email.find({ to: email }).sort({ date: -1 });
  res.send(messages);
});

// === ðŸ“„ GET SPECIFIC MESSAGE BY INDEX ===
app.get('/inbox/:email/:index', authKey, async (req, res) => {
  const email = req.params.email;
  const index = parseInt(req.params.index);
  const messages = await Email.find({ to: email }).sort({ date: -1 });
  if (index < 0 || index >= messages.length) {
    return res.status(404).send('Message not found');
  }
  res.send(messages[index]);
});

// === ðŸ§¹ DELETE ALL MESSAGES ===
app.delete('/delete/:email', authKey, async (req, res) => {
  const email = req.params.email;
  await Email.deleteMany({ to: email });
  res.send('ðŸ—‘ï¸ All messages deleted');
});

// === âŒ DELETE SPECIFIC MESSAGE ===
app.delete('/delete/:email/:index', authKey, async (req, res) => {
  const email = req.params.email;
  const index = parseInt(req.params.index);
  const messages = await Email.find({ to: email }).sort({ date: -1 });
  if (index < 0 || index >= messages.length) {
    return res.status(404).send('Message not found');
  }
  await Email.findByIdAndDelete(messages[index]._id);
  res.send('ðŸ—‘ï¸ Message deleted');
});

// === ðŸ“± DEVICE-BASED EMAIL MANAGEMENT ===

// Get all emails for a device
app.get('/device/:deviceId/emails', authKey, async (req, res) => {
  const deviceId = req.params.deviceId;
  try {
    const emails = await DeviceEmail.find({ deviceId }).sort({ createdAt: -1 });
    res.json(emails);
  } catch (err) {
    console.error('Error fetching device emails:', err);
    res.status(500).send('Error fetching emails');
  }
});

// Get generated emails for a device
app.get('/device/:deviceId/generated', authKey, async (req, res) => {
  const deviceId = req.params.deviceId;
  try {
    const emails = await DeviceEmail.find({ 
      deviceId, 
      type: 'generated' 
    }).sort({ createdAt: -1 });
    res.json(emails);
  } catch (err) {
    console.error('Error fetching generated emails:', err);
    res.status(500).send('Error fetching generated emails');
  }
});

// Get received emails for a device
app.get('/device/:deviceId/received', authKey, async (req, res) => {
  const deviceId = req.params.deviceId;
  try {
    const emails = await DeviceEmail.find({ 
      deviceId, 
      type: 'received' 
    }).sort({ receivedAt: -1 });
    res.json(emails);
  } catch (err) {
    console.error('Error fetching received emails:', err);
    res.status(500).send('Error fetching received emails');
  }
});

// Get received emails for a specific generated email
app.get('/device/:deviceId/inbox/:email', authKey, async (req, res) => {
  const { deviceId, email } = req.params;
  try {
    const emails = await DeviceEmail.find({ 
      deviceId, 
      email, 
      type: 'received' 
    }).sort({ receivedAt: -1 });
    res.json(emails);
  } catch (err) {
    console.error('Error fetching inbox emails:', err);
    res.status(500).send('Error fetching inbox emails');
  }
});

// Delete all emails for a device
app.delete('/device/:deviceId/clear', authKey, async (req, res) => {
  const deviceId = req.params.deviceId;
  try {
    await DeviceEmail.deleteMany({ deviceId });
    res.send('ðŸ—‘ï¸ All device emails deleted');
  } catch (err) {
    console.error('Error clearing device emails:', err);
    res.status(500).send('Error clearing emails');
  }
});

// Delete a specific email for a device
app.delete('/device/:deviceId/email/:emailId', authKey, async (req, res) => {
  const { deviceId, emailId } = req.params;
  try {
    const result = await DeviceEmail.findOneAndDelete({ 
      _id: emailId, 
      deviceId 
    });
    if (!result) {
      return res.status(404).send('Email not found');
    }
    res.send('ðŸ—‘ï¸ Email deleted');
  } catch (err) {
    console.error('Error deleting email:', err);
    res.status(500).send('Error deleting email');
  }
});

// === ðŸ”§ ADMIN PANEL ROUTES ===

// Serve admin panel
app.get('/admin', (req, res) => {
  res.sendFile(path.join(__dirname, 'public', 'admin.html'));
});

// Get domains from Haraka host_list
app.get('/admin/domains', authKey, (req, res) => {
  try {
    if (fs.existsSync(HARAKA_HOST_LIST_PATH)) {
      const hostListContent = fs.readFileSync(HARAKA_HOST_LIST_PATH, 'utf8');
      const domains = hostListContent
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
      res.json(domains);
    } else {
      res.json([]);
    }
  } catch (err) {
    console.error('Error reading host_list:', err);
    res.status(500).send('Error reading domains');
  }
});

// Add domain to Haraka host_list
app.post('/admin/domains/add', authKey, (req, res) => {
  const { domain } = req.body;
  
  if (!domain) {
    return res.status(400).send('Domain is required');
  }
  
  try {
    let hostListContent = '';
    if (fs.existsSync(HARAKA_HOST_LIST_PATH)) {
      hostListContent = fs.readFileSync(HARAKA_HOST_LIST_PATH, 'utf8');
    }
    
    const domains = hostListContent
      .split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'));
    
    if (domains.includes(domain)) {
      return res.status(400).send('Domain already exists');
    }
    
    // Add domain to the list
    domains.push(domain);
    
    // Write back to file
    const newContent = domains.join('\n') + '\n';
    fs.writeFileSync(HARAKA_HOST_LIST_PATH, newContent, 'utf8');
    
    console.log(`âœ… Domain '${domain}' added to host_list`);
    res.send(`âœ… Domain '${domain}' added successfully`);
  } catch (err) {
    console.error('Error adding domain:', err);
    res.status(500).send('Error adding domain');
  }
});

// === ðŸ” SYSTEM MONITORING & RECOVERY ENDPOINTS ===

// System health check
app.get('/admin/health', authKey, async (req, res) => {
  try {
    const health = {
      timestamp: new Date().toISOString(),
      database: 'unknown',
      failedEmailsLog: fs.existsSync(FAILED_EMAILS_LOG),
      totalEmails: 0,
      totalDeviceEmails: 0,
      connectedClients: io.engine.clientsCount || 0
    };
    
    // Check database connection
    try {
      await mongoose.connection.db.admin().ping();
      health.database = 'connected';
      
      // Get email counts
      health.totalEmails = await Email.countDocuments();
      health.totalDeviceEmails = await DeviceEmail.countDocuments();
    } catch (dbErr) {
      health.database = 'disconnected';
      health.databaseError = dbErr.message;
    }
    
    // Check failed emails log size
    if (health.failedEmailsLog) {
      try {
        const stats = fs.statSync(FAILED_EMAILS_LOG);
        health.failedEmailsLogSize = stats.size;
        
        if (stats.size > 0) {
          const logContent = fs.readFileSync(FAILED_EMAILS_LOG, 'utf8');
          const lines = logContent.trim().split('\n').filter(line => line);
          health.failedEmailsCount = lines.length;
        } else {
          health.failedEmailsCount = 0;
        }
      } catch (logErr) {
        health.failedEmailsLogError = logErr.message;
      }
    }
    
    res.json(health);
  } catch (err) {
    console.error('Error checking system health:', err);
    res.status(500).json({ error: 'Error checking system health', message: err.message });
  }
});

// Retry failed emails
app.post('/admin/retry-failed-emails', authKey, async (req, res) => {
  try {
    const result = await retryFailedEmails();
    res.json({
      success: true,
      result,
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    console.error('Error retrying failed emails:', err);
    res.status(500).json({ error: 'Error retrying failed emails', message: err.message });
  }
});

// Get failed emails log
app.get('/admin/failed-emails', authKey, (req, res) => {
  try {
    if (!fs.existsSync(FAILED_EMAILS_LOG)) {
      return res.json({ emails: [], count: 0 });
    }
    
    const logContent = fs.readFileSync(FAILED_EMAILS_LOG, 'utf8');
    const lines = logContent.trim().split('\n').filter(line => line);
    
    const emails = lines.map(line => {
      try {
        return JSON.parse(line);
      } catch (parseErr) {
        return { error: 'Invalid JSON', line };
      }
    });
    
    res.json({ emails, count: emails.length });
  } catch (err) {
    console.error('Error reading failed emails log:', err);
    res.status(500).json({ error: 'Error reading failed emails log', message: err.message });
  }
});

// Clear failed emails log
app.delete('/admin/failed-emails', authKey, async (req, res) => {
  try {
    await writeFile(FAILED_EMAILS_LOG, '');
    res.json({ success: true, message: 'Failed emails log cleared', timestamp: new Date().toISOString() });
  } catch (err) {
    console.error('Error clearing failed emails log:', err);
    res.status(500).json({ error: 'Error clearing failed emails log', message: err.message });
  }
});

// Get system statistics
app.get('/admin/stats', authKey, async (req, res) => {
  try {
    const stats = {
      timestamp: new Date().toISOString(),
      emails: {
        total: await Email.countDocuments(),
        today: await Email.countDocuments({
          date: { $gte: new Date().toISOString().split('T')[0] }
        })
      },
      deviceEmails: {
        total: await DeviceEmail.countDocuments(),
        generated: await DeviceEmail.countDocuments({ type: 'generated' }),
        received: await DeviceEmail.countDocuments({ type: 'received' }),
        uniqueDevices: (await DeviceEmail.distinct('deviceId')).length
      },
      domains: ALLOWED_DOMAINS.length,
      connectedClients: io.engine.clientsCount || 0
    };
    
    res.json(stats);
   } catch (err) {
     console.error('Error getting system stats:', err);
     res.status(500).json({ error: 'Error getting system stats', message: err.message });
   }
 });

// Delete domain from Haraka host_list
app.delete('/admin/domains/delete', authKey, (req, res) => {
  const { domain } = req.body;
  
  if (!domain) {
    return res.status(400).send('Domain is required');
  }
  
  try {
    if (!fs.existsSync(HARAKA_HOST_LIST_PATH)) {
      return res.status(404).send('Host list file not found');
    }
    
    const hostListContent = fs.readFileSync(HARAKA_HOST_LIST_PATH, 'utf8');
    const domains = hostListContent
      .split('\n')
      .map(line => line.trim())
      .filter(line => line && !line.startsWith('#'));
    
    const filteredDomains = domains.filter(d => d !== domain);
    
    if (domains.length === filteredDomains.length) {
      return res.status(404).send('Domain not found');
    }
    
    // Write back to file
    const newContent = filteredDomains.join('\n') + '\n';
    fs.writeFileSync(HARAKA_HOST_LIST_PATH, newContent, 'utf8');
    
    console.log(`ðŸ—‘ï¸ Domain '${domain}' removed from host_list`);
    res.send('Domain deleted successfully');
  } catch (err) {
    console.error('Error deleting domain:', err);
    res.status(500).send('Error deleting domain');
  }
});

// Get admin statistics
app.get('/admin/stats', authKey, async (req, res) => {
  try {
    const totalEmails = await Email.countDocuments();
    
    let totalDomains = 0;
    if (fs.existsSync(HARAKA_HOST_LIST_PATH)) {
      const hostListContent = fs.readFileSync(HARAKA_HOST_LIST_PATH, 'utf8');
      const domains = hostListContent
        .split('\n')
        .map(line => line.trim())
        .filter(line => line && !line.startsWith('#'));
      totalDomains = domains.length;
    }
    
    // Get unique email addresses from last 24 hours (as active users)
    const yesterday = new Date();
    yesterday.setDate(yesterday.getDate() - 1);
    
    const recentEmails = await Email.find({
      date: { $gte: yesterday.toISOString() }
    });
    
    const uniqueRecipients = new Set();
    recentEmails.forEach(email => {
      if (Array.isArray(email.to)) {
        email.to.forEach(recipient => uniqueRecipients.add(recipient));
      } else {
        uniqueRecipients.add(email.to);
      }
    });
    
    const activeUsers = uniqueRecipients.size;
    
    res.json({
      totalEmails,
      totalDomains,
      activeUsers
    });
  } catch (err) {
    console.error('Error getting stats:', err);
    res.status(500).send('Error getting statistics');
  }
});

// Get recent emails for monitoring
app.get('/admin/recent-emails', authKey, async (req, res) => {
  try {
    const recentEmails = await Email.find()
      .sort({ date: -1 })
      .limit(50);
    res.json(recentEmails);
  } catch (err) {
    console.error('Error getting recent emails:', err);
    res.status(500).send('Error getting recent emails');
  }
});

// === ðŸ”‘ API KEY MANAGEMENT ===

// Get current API key
app.get('/admin/current-api-key', authKey, (req, res) => {
  res.json({ apiKey: API_KEY });
});

// Update API key
app.post('/admin/update-api-key', authKey, (req, res) => {
  const { newApiKey } = req.body;
  
  if (!newApiKey) {
    return res.status(400).send('New API key is required');
  }
  
  if (newApiKey.length < 8) {
    return res.status(400).send('API key must be at least 8 characters long');
  }
  
  // Update the API key
  API_KEY = newApiKey;
  
  console.log(`ðŸ”‘ API key updated successfully`);
  res.send('API key updated successfully');
});

// === ðŸ§ª SYSTEM TESTING ===

// Test MongoDB connection
app.get('/admin/test-mongo', authKey, async (req, res) => {
  try {
    // Try to perform a simple database operation
    await mongoose.connection.db.admin().ping();
    res.json({ status: 'connected', message: 'MongoDB connection is healthy' });
  } catch (err) {
    console.error('MongoDB test failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

// Test Haraka integration
app.get('/admin/test-haraka', authKey, (req, res) => {
  try {
    // Check if Haraka host_list file exists and is readable
    if (fs.existsSync(HARAKA_HOST_LIST_PATH)) {
      const stats = fs.statSync(HARAKA_HOST_LIST_PATH);
      if (stats.isFile()) {
        // Try to read the file
        const content = fs.readFileSync(HARAKA_HOST_LIST_PATH, 'utf8');
        const domains = content.split('\n').filter(line => line.trim() && !line.startsWith('#'));
        res.json({ 
          status: 'active', 
          message: `Haraka integration active with ${domains.length} domains`,
          domains: domains.length
        });
      } else {
        res.status(500).json({ status: 'error', message: 'Host list path is not a file' });
      }
    } else {
      res.status(500).json({ status: 'error', message: 'Haraka host_list file not found' });
    }
  } catch (err) {
    console.error('Haraka test failed:', err);
    res.status(500).json({ status: 'error', message: err.message });
  }
});

// Test all system components
app.get('/admin/test-system', authKey, async (req, res) => {
  const results = {
    timestamp: new Date().toISOString(),
    tests: []
  };
  
  // Test MongoDB
  try {
    await mongoose.connection.db.admin().ping();
    results.tests.push({ component: 'MongoDB', status: 'success', message: 'Connected' });
  } catch (err) {
    results.tests.push({ component: 'MongoDB', status: 'error', message: err.message });
  }
  
  // Test Haraka integration
  try {
    if (fs.existsSync(HARAKA_HOST_LIST_PATH)) {
      const content = fs.readFileSync(HARAKA_HOST_LIST_PATH, 'utf8');
      const domains = content.split('\n').filter(line => line.trim() && !line.startsWith('#'));
      results.tests.push({ component: 'Haraka', status: 'success', message: `${domains.length} domains configured` });
    } else {
      results.tests.push({ component: 'Haraka', status: 'error', message: 'Host list file not found' });
    }
  } catch (err) {
    results.tests.push({ component: 'Haraka', status: 'error', message: err.message });
  }
  
  // Test email count
  try {
    const emailCount = await Email.countDocuments();
    results.tests.push({ component: 'Email System', status: 'success', message: `${emailCount} emails in database` });
  } catch (err) {
    results.tests.push({ component: 'Email System', status: 'error', message: err.message });
  }
  
  res.json(results);
});

// === START SERVER ===
server.listen(PORT, '0.0.0.0', () => {
  console.log(`ðŸš€ API & Socket.IO server running on port ${PORT}`);
  console.log(`ðŸ“Š Admin panel available at: http://localhost:${PORT}/admin`);
});
